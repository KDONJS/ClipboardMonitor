name: Rust CI

on:
  push:
    branches: [ "master" ]
  pull_request:
    branches: [ "develop", "master" ]

env:
  CARGO_TERM_COLOR: always

jobs:
  build:
    name: ğŸ“¦ Build y Linter
    runs-on: ubuntu-latest

    steps:
    - name: ğŸ“¥ Clonar repositorio
      uses: actions/checkout@v4

    - name: ğŸ¦€ Instalar Rust Stable
      uses: dtolnay/rust-toolchain@stable
      with:
        components: clippy, rustfmt

    - name: ğŸ“¦ Instalar dependencias del sistema
      run: sudo apt update && sudo apt install -y libx11-dev libxcb1-dev

    - name: ğŸ” Formatear cÃ³digo con rustfmt
      run: cargo fmt -- --check

    - name: ğŸ›  Revisar cÃ³digo con Clippy
      run: cargo clippy --all-targets --all-features -- -D warnings

    - name: ğŸ”¨ Compilar el proyecto
      run: cargo build --release --verbose

  security:
    name: ğŸ”’ AnÃ¡lisis de Seguridad
    runs-on: ubuntu-latest
    needs: build

    steps:
    - name: ğŸ“¥ Clonar repositorio
      uses: actions/checkout@v4

    - name: ğŸ¦€ Instalar Rust Stable
      uses: dtolnay/rust-toolchain@stable

    - name: ğŸ›¡ Ejecutar Cargo Audit
      run: |
        cargo install cargo-audit
        cargo audit || true

  miri:
    name: ğŸ” AnÃ¡lisis de Memoria con Miri (Rust Nightly)
    runs-on: ubuntu-latest
    needs: security

    steps:
    - name: ğŸ“¥ Clonar repositorio
      uses: actions/checkout@v4

    - name: ğŸŒ™ Instalar Rust Nightly con Miri
      uses: dtolnay/rust-toolchain@nightly
      with:
        components: miri

    - name: ğŸ•µï¸ Ejecutar Miri
      run: cargo miri test || true  # No queremos que el pipeline falle si hay warnings

  test:
    name: âœ… Pruebas y Benchmarks
    runs-on: ubuntu-latest
    needs: security

    steps:
    - name: ğŸ“¥ Clonar repositorio
      uses: actions/checkout@v4

    - name: ğŸ¦€ Instalar Rust Stable
      uses: dtolnay/rust-toolchain@stable

    - name: ğŸ”¬ Ejecutar pruebas unitarias
      run: cargo test --verbose

    - name: âš¡ Ejecutar benchmarks de performance
      run: cargo bench || true  # No queremos que el pipeline falle si un benchmark es lento
